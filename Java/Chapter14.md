# Chapter 14
## 멀티 스레드
>참고 문헌 : 이것이 자바다

### 14.1 멀티 스레드
운영체제는 실행 중인 프로그램을 **프로세스로 관리**한다. 멀티 태스킹은 두가지 이상의 작업을 동시에 처리하는 것을 말하는데, 운영 체제는 `멀티 프로세스`를 생성하여 처리한다.
하나의 프로세스 내에서 멀티 태스킹을 할 수 있도록 만들어진 프로그램도 있다.
하나의 프로세스가 두 가지 이상의 작업을 처리할 수 있는 이유는 `멀티 스레드`가 있기 때문이다.
`스레드`는 **코드의 실행 흐름**을 말하는데 프로세스 내에 스레드가 두개라면 두개의 코드 실행 흐름이 생긴다는 의미이다.
`멀티 프로세스`는 프로그램 단위의 멀티 태스킹이라면 멀티 스레드는 프로그램 내부에서의 멀티 태스킹이다.
멀티 프로세스들은 **서로 독립적**이기 때문에 하나의 프로세스에서 오류가 나도 다른 프로세스에 영향을 미치지 않는다.
`멀티 스레드`는 **프로세스 내부에서 생성**되기 때문에 하나의 스레드가 예외를 발생시키면 프로세스가 종료되어 다른 스레드에게 영향을 미친다.

### 14.2 메인 스레드
모든 자바 프로그램은 `메인 스레드`가 `main() 메소드`를 실행하면서 시작된다. 메인 스레드는 main()메소드의 첫 코드부터 순차적으로 실행하고, main() 메소드의 마지막 코드를 실행하거나 return 문을 만나면 실행을 종료한다.
메인 스레드는 필요에 따라 추가 작업 스레드를 만들어서 실행시킬 수 있다. 
멀티 스레드는 `실행 중인 스레드`가 하나라도 있다면 **프로세스는 종료되지 않는다**.

### 14.3 작업 스레드 생성과 실행
멀티 스레드로 실행하는 프로그램을 개발하려면 먼저 **몇개의 작업**을 `병렬`로 실행할지 결정하고 각 작업별로 스레드를 생성해야 한다.
자바 프로그램은 메인 스레드 반드시 존재하므로 메인 작업 이외에 추가적인 작업 수만큼 스레드를 생성하면 된다.
Thread 클래스로 직접 객체 생성해도 되지만 하위 클래스를 만들어 생성할 수 있다.
#### 직접 스레드 생성
* java.lang 패키지의 Thread 클래스로 작업 스레드 객체 직접 생성(Runnable 구현 객체를 매개값으로 갖는 생성자 호출)
* ```
  Thread thread = new Thread(Runnable target);
    ```
* Runnable은 스레드가 작업을 실행할 때 사용하는 인터페이스
* run()메소드를 구현 클래스에서 재정의하여 스레드가 실행할 코드를 가지고 있어야 한다.
* ```
  class Task implements Runnable{
  @Override
  public void run(){
  //스레드가 실행할 코드
  }
  }
    ```
* 구현 클래스는 작업 내용을 정의한 것으로 스레드에게 전달.
* ```
  Runnable task = new Task(); //Runnable 구현객체 생성
  Thread thread = new Thread(task); // Thread 생성자 매개값으로 객체를 전달
    ```
* 구현 클래스 작성하지 않고 Thread 생성자 호출할 때 Runnable 익명 구현 객체를 매개값으로 사용할 수 있다.
* 더 많이 사용되는 방법
* ```
  Thread thread = new Thread (new Runnable(){
  @Override
  public void run(){
  //스레드가 실행할 코드
  }
  });
    ```
* 작업 스레드를 생성 후 실행하려면 스레드 객체의 start() 메소드를 호출한다.
* `thread.start()`
* start()가 호출되면, run() 메소드 부터 실행하면서 작업을 처리한다.
#### Thread 자식 클래스로 생성
* Thread 클래스를 상속한 다음 run()메소드를 재정의해서 스레드가 실행할 코드를 작성하고 객체를 생성
* ```
  public class WorkerThread extends Thread{
  @Override
  public void run(){
  //스레드가 실행할 코드
  }
  }
  //스레드 객체 생성
  Thread thread = new WorkterThread();
    ```
* Thread 익명 자식 객체를 사용하는 방법이 더 많이 사용된다.
* ```
  Thread thread = new Thread (){
  @Override
  public void run(){
  //스레드가 실행할 코드
  }
  };
  thread.start();
    ```
## 14.4 스레드 이름
* 작업 스레드는 `Thread-n`이라는 이름을 갖는다.
* 이름 설정 시 `thread.setName()`메소드 사용
* `currentThread()`메소드로 현재 작업 중인 **스레드 객체의 참조를 얻고** getName()메소드로 이름 출력하여 확인가능

### 14.5 스레드 상태
* 스레드를 객체 생성 후 start()메소드 호출시 스레드는 실행 대기 상태(`Runnable`)가 된다.
* **run() 메소드를 실행**하는 것을 `실행 상태`라 한다.
* 실행 스레드는 run()메소드 모두 실행 전에 스케줄링에 의해 다시 실행 대기로 넘어갈 수 있다. 다른 스레드가 실행 상태가 된다.
* run()메소드가 실행상태에서 종료되면 더이상 실행할 코드가 없기 때문에 `종료 상태`라고 한다.
* 실행 상태에서 일시 정지 상태로 가기도 하는데, 일시정지 상태는 스레드가 실행할수 없는 상태
* 실행 상태로 가기 위해 일시 정지 상태에서 실행 대기 상태로 가야한다.
* 일시 정지로 보내는 메소드는 sleep(long millis)[주어진 시간이 지나면 자동 실행 대기 상태], join()[실행 대기 상태가 되려면 join()메소드를 가진 스레드가 종료], wait()[동기화 블록 내에서 스레드 일시정지 상태로 만듦]
* 일시 정지에서 벗어나느 메소드는 interrupt(), notify(), notifyAll()
* 실행 대기로 보내는 메소드는 yield()[다른 스레드에게 실행을 양보하고 자신은 실행 대기 상태로 간다]가 있다.
* 제한된 타입 파라미터 : 특정 타입과 자식 또는 구현 관계에 있는 타입만 대체할 수 있는 타입 파라미터
* wait(), notify(), notifyAll()은 Object 클래스의 메소드
* 나머지는 Thread메소드

### 14.6 스레드 동기화
* 멀티 스레드는 하나의 객체를 공유해서 작업 할 수 있다.
* 스레드가 사용중인 객체를 다른 스레드가 변경할 수 없도록 스레드 작업이 끝날때까지 객체에 잠금을 건다.
* 자바는 동기화 메소드와 블록을 제공한다.
* 객체 내부에 동기화 메소드와 동기화 블록이 여러개가 있다면 스레드가 이들 중 하나를 실행할 때, 다른 스레드는 다른 동기화 메소드 및 블록을 실행 할 수 없다. 일반 메소드는 실행이 가능하다.
* 동기화 메소드를 선언하는 방법
* `public synchronized void method(){// 단 하나의 스레드만 실행하는 영역}`
* 스레드가 동기화 메소드를 실행하는 즉시 객체는 잠금이 되고 메소드 실행이 되면 잠금이 풀린다.
* ```
    public void method(){
    //여러 스레드가 실행할수 잇는 영역
  
  synchronized(공유객체){
  //단 하나의 스레드만 실행하는 영역
  }
  //여러 스레드가 실행할 수 있는 영역
  }
    ```
* 경우에 따라 두개의 스레드를 교대로 번갈아 가며 실행할 수 있다.자신의 작업이 끝나면 상대의 스레드 일시정지를 풀어주고 자신이 일시정지 상태가 되면 된다.
* 두 스레드가 작업하는 내용을 동기화 메소드로 정하고 한 스레드가 작업을 마치면, notify()메소드를 호출해서 다른 스레드를 실행 대기 상태로 만들고 자신은 wait()메소드를 호출하여 일시 정시 상태로 만든다. 
* notifyAll()은 wait()에 의해 일시 정지된 모든 스레드를 실행 대기 상태로 만든다.
* notify와 notifyAll은 동기화 메소드나 동기화 블록 내에서만 사용 가능
### 14.7 스레드 안전 종료
* 스레드는 자신의 run() 메소드가 모두 실행되면 자동적으로 종료, 경우에 따라 실행 중인 스레드를 즉시 종료할 필요가 있다.
* 강제 종료시키기 위해 stop() 메소드를 제공하지만 이제 더이상 사용하지 ㅇ낳는다. 
* 스레드를 안전하게 종료하는 방법은 사용하던 리소스들을 정리하ㅣ고 run()멧소드를 빨리 종료하는 것이다. 조건 이용 방법과 interrupt()메소드 이용방법을 사용한다.
#### 조건 이용
* while문을 반복 실행하면 조건을 이용해 run() 메소드 종료를 유도할 수 있다.
* ```
    public class ...Thread extends Thread{
    private boolean stop; -> stop 필드 선언
    
    public void run(){
    while (!stop){ ->stop이 true문 되면 while문 빠져나감
    //스레드가 반복 실행하는 코드
  }
  //스레드가 사용한 리소스 정리 -> 리소스 정리
  }-> 스레드 종료
  
  
  }
    ```
#### interrupt()메소드 이용
* interrupt메소드는 스레드가 일시정지 상태에서 InterruptedException 예외를 발생시키는 여갈
* 에외처리를 통해 run() 메소드 정상 종료 가능.
* 스레드가 실행대기 또는 실행 상태 일때는 Interrupt()메소드가 호출되어도 예외가 발생하지 않는다.
* 일시 정지를 위해서 짧은 시간이라도 thread.sleep(1)를 사용한다.
* Thread.interrupted() 정적 메소드 와 isInterrupted() 인스턴스 메소드로 interrupt 메소드 호출 여부를 리턴(Boolean)한다.
### 14.8 데몬 스레드
* 데몬스레드 : 주 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드.
* 주스레드가 종료되면 자동으로 종료
* 자동저장, 가비지 컬렉터 등이 데몬 스레드 적용의 예
* 스레드를 데몬으로 만들기 위해서 주 스레드가 데몬이 될 스레드의 setDaemon(true)를 호출한다.

### 14.9 스레드풀
* 병렬 작업 증가로 인한 스레드 폭증을 막기 위해 스레드풀을 사용한다.
* 스레드풀 : 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓고 작업 큐에 들어오는 작업들을 ㅅ그레드가 하나씩 맡아 처리하는 방식
* 작업처리가 끝난 스레드는 다시 작업 큥에서 새로운 작업을 가져와 처리
* 작업량은 증가해도 스레드 개수가 증가하지 않아 어플리케이션의 성능이 저하되지 않음
#### 스레드 풀 생성하기 위해 java.util.concurrent 패키지에서 ExecutorService 인터페이스와 Executors 클래스를 제공한다.
* Executors의 두 정적 메소드
* 1. newCachedThreadPool() : 초기수 0, 코어수 0 , 최대수 Integer_MAX_VALUE
* 2. newFixedThreadPool(int nThreads) : 초기 수 0, 코어수 생성된 수, 최대수 nThreads
* `초기 수`는 스레드 풀이 생성될 때 기본적으로 생성되는 스레드 수
* `코어수`는 스레드가 증가된 후 사용되지 않는 스레드를 제거할 때 최소한 풀에서 유지하는 스레드 수
* `최대 수`는 증가되는 스레드의 한도 수
#### 스레드 종료하기 위해 ExecutorService의 두 메소드 중 하나를 실행
* 1. shutDown() : 현재 처리 중인 작업 뿐만 아니라 작업 큐에 대기하고 있는 모든 작업을 처리한 뒤에 스레드 풀 종료
* 2. shutDownNow() : 현재 작업 처리 중인 스레드를 **interrupt**해서 작업을 중단시키고 스레드 풀을 종료시킨다. 리턴값은 작업 큐에 있는 미처리된 작업의 목록이다.
#### 작업 생성과 처리 요청
* 하나의 작업은 `Runnable` 또는 `Callable` 구현 객체로 표현
* 둘의 차이는 작업 처리 완료 후 리턴 값의 유무이다. Callable은 지정한 타입 파라미터 T와 동일한 타입의 리턴 값을 가진다.

