# Chapter 11
## 예외 처리
>참고 문헌 : 이것이 자바다

### 11.1 예외와 예외 클래스
* 에러 : 하드웨어의 고장으로 인해 응용프로그램 실행 오류가 발생하는 것
* 예외 : 잘못된 사용 또는 코딩으로 인한 오류 , 발생 시 프로그램 종료
* `예외 처리`로 계속 실행 상태 유지 가능
* * 일반 예외 : 컴파일러가 예외 처리 코드 여부를 검사하는 예외
* * 실행 예외 : 컴파일러가 예외 처리 코드 여부를 검사하지 않는 예외
* 예외 클래스로부터 객체를 생성하고 객체는 예외 처리 시 사용
* 모든 에러와 예외 클래스는 Throwable을 상속받아 만들어진다. 
* 실행 예외는 RuntimeException과 그 자식 클래스에 해당한다. 그 외 클래스는 모두 일반 예외이다.
* 
### 11.2 예외 처리 코드

* 예외 처리 코드 : 프로그램의 갑작스러운 종료를 막고 정상 실행을 유지할 수 있도록 처리하는 코드
* try - catch - finally블록으로 구성된다.
* `생성자 내부`와 `메소드 내부`에서 작성된다.
* 예외 없이 정상 실행되면 catch 블록 실행 안하고 finally블록 실행
* 예외 발생되면 catch문 실행되고 finally블록 실행
* **finally는 항상 실행**, 생략 가능

#### 예외 정보 출력하는 3가지 방법 
1. getMessage() : 예외 발생 이유
2. toString() : 예외 발생 이유, 예외의 종류 리턴
3. printStackTrace() : 예외가 어디서 발생했는지 추적한 내용


### 11.3 예외 종류에 따른 처리

* try 블록에서 다양한 종류의 예외 발생 시 다중 catch를 사용하면 발생하는 예외마다 예외 처리 코드를 다르게 작성할 수 있다.
* catch문이 여러개라도 하나만 실행 ->try블록에서 동시 다발적으로 예외가 발생하지 않으며 예외 발생하면 즉시 중단되기 때문
* 처리해야할 예외 클래스들이 상속 관계라면 하위 클래스 catch 먼저 작성 -> **하위 예외도 상위 클래스 타입이기 때문에**
* 두 개 이상의 예외를 하나의 catch 블록으로 동일하게 예외 처리 하고 싶을 때는 `|`기호로 연결
### 11.4 리소스 자동 닫기
* 리소스 : 데이터를 제공하는 객체
* 리소스 사용 -> open, 사용 종료 -> close
* try-catch-finally 문에서 리소스 사용 시,finally문에서 close한다.

#### try-with-resources
* try 괄호에 리소스 여는 코드 작성 후 실행 완료나 예외 발생 시 리소스 자동 종료
* `java.lang.AutoCloseable` 인터페이스 구현하여 close() 메소드 재정의
```
    @Override
    public void close() throws Exception{
    
    }
```
### 11.5 예외 떠넘기기
* 메소드를 호출한 곳으로 예외를 떠넘기기. -> `throws`
* 떠넘길 예외 클래스를 쉼표로 구분해서 나열
* 떠넘긴 예외는 메소드를 호출하는 곳에서 예외를 받아 처리해야 한다. 

`리턴타입 메소드명(매개변수, ..) throws 예외클래스1, 예외클래스2 {...}`
* 나열해야 할 예외 클래스가 많으면 throws Exception 또는 throws Throwable 만으로 예외 떠넘기기 가능
`리턴타입 메소드명(매개변수, ..) throws Exception {...}`
* 디폴트 메소드는 구현 객체가 필요하기 때문에 추상 메소드를 구현한 객체를 인터페이스 변수에 대입해야 한다.
* 구현 클래스는 디폴트 메소드를 재정의해서 자신에게 맞게 수정할 수 있다. 재정의 시, public 접근 제한자를 붙이고, default 키워드를 생략해야 한다.

### 11.6 사용자 정의 예외

* 사용자 정의 예외 : 컴파일러가 체크하는 일반 예외로 선언할 수 있고, 컴파일러가 체크하지 않는 실행 예외로 선언할 수도 있다.
* 일반 예외는 Exception의 자식 클래스로 선언, 실행 예외는 RuntimeException의 자식 클래스로 선언
```
    public class ..Exception extends [Exception| RuntimeException]{
    public ...Exception(){
    //기본 생성자
    }
    public ...Exception(String message){
    //예외 메시지를 입력받는 생성자
    super(message);
    }
    }
```
* 정적 메소드의 실행부 작성시, 상수 필드를 제외한 **추상 메소드, 디폴트 메소드, private 메소드 등을 호출할 수 없다!**
  -> `구현 객체가 필요한 인스턴스 메소드이기 때문`


### 8.7 private 메소드
* 인터페이스에 외부에서 접근할 수 없는 `private 메소드`는 구현 객체가 필요한 메소드이다.
* private 메소드는 디폴트 메소드 안에서만 호출이 가능하지만, private 정적 메소드는 디폴트 메소드뿐만 아니라 정적 메소드 안에서도 호출이 가능하다.
* **디폴트와 정적 메소드들의 중복 코드를 줄이기 위함이다.**

### 8.8 다중 인터페이스 구현
* 구현 객체는 여러 개의 인터페이스를 implements할 수 있다.
* 구현 객체가 인터페이스A와 인터페이스B를 구현하고 있다면 각각의 인터페이스를 통해 구현 객체를 사용할 수 있다.

```
public class 구현 클래스명 implements 인터페이스A, 인터페이스B{

// 모든 인터페이스가 가진 추상 메소드를 재정의해야 한다.

}
```
* 두 인터페이스를 구현한 객체는 두 인터페이스 타입의 변수에 각각 대입될 수 있다.
```
 인터페이스A 변수 = new 구현 클래스명();
 인터페이스B 변수 = new 구현 클래스명();
```

### 8.9 인터페이스 상속
* 인터페이스는 **다른 인터페이스를 상속**할 수 있다.
* 클래스와 달리 `다중 상속`이 가능하다!
```
public interface 자식인터페이스 extends 부모인터페이스1, 부모인터페이스2{....}
```
* 자식 인터페이스의 구현 클래스는 자식 인터페이스의 메소드 뿐만 아니라 **부모 인터페이스의 모든 추상 메소드를 재정의**해야 한다.
* 구현 객체는 자식 및 부모 인터페이스 변수에 대입될 수 있다.
```
 자식 인터페이스 변수 = new 구현 클래스명();
 부모 인터페이스A 변수 = new 구현 클래스명();
 부모 인터페이스B 변수 = new 구현 클래스명();
```
* 구현 객체가 자식 인터페이스 변수에 대입되면 자식과 부모 인터페이스의 추상 메소드 모두 호출 가능
* 구현 객체가 부모 인터페이스 변수에 대입되면 부모 인터페이스에 선언된 추상 메소드만 호출 가능

### 8.10 타입 변환
* 인터페이스의 타입 변환은 인터페이스와 구현 클래스 간에 발생
* 인터페이스 변수 ->구현 객체를 대입하면 구현 객체는 인터페이스로 **자동 타입 변환**
* 인터페이스 타입 -> 구현 클래스 타입으로 변환 **(강제 타입 변환)**
#### 강제 타입 변환
* `캐스팅 기호(캐스팅할 구현 클래스명)`를 사용하여 인터페이스 타입 -> 구현 클래스 타입으로 변환


### 8.11 다형성
* 필드 타입으로 인터페이스를 선언하면 필드값으로 구현 객체를 대입할 수 있다.
```
 public class Car{
    Tire tire1 = new HanKookTire();
    Tire tire2 = new kumhoTire();
 }
```
* Car 객체 생성후 다른 구현 객체를 대입할 수도 있다.
```
Car myCar = new Car();
myCar.tire1 = new KumhoTire(); // 다른 객체 대입
```

#### 매개변수의 다형성
* 메소드 호출 시 매개값을 다양하기 위해 상속에서 매개변수 타입을 부모 타입으로 선언하고 호출 시 다양한 자식 객체를 대입했다.
* 매개 변수 타입을 인터페이스로 선언하면 메소드 호출 시 다양한 구현 객체를 대입할 수 있다.
* 인터페이스의 구현 객체를 매개값으로 줄 수 있다.
* 구현 객체에 재정의된 메소드 실행 내용이 다 다르기 때문에 어떤 객체가 매개값으로 들어오냐에 따라 결과가 다르게 나타난다.`(매개변수의 다형성)`
### 8.12 객체 타입 확인
* 인터페이스에서 객체 타입을 확인하기 위해 `instanceof 연산자`를 사용한다.
* 메소드의 매개변수가 인터페이스 타입이면 메소드 호출 시 매개값은 해당 인터페이스를 구현하는 모든 객체가 될 수 있다.
* 만약 매개값이 특정 구현 객체일 경우에만 강제 타입 변환을 하고 싶다면 `instanceof 연산자` 사용하여 매개값의 타입을 검사한다.
```
    public void method(Vehicle vehicle){
    if(vehicle instanceof Bus){
        Bus bus = (Bus) vehicle;
        }
        }
```
* **Java 12**부터는 강제 타입 변환 없이 우측 타입 변수를 사용할 수 있다.

### 8.13 봉인된 인터페이스
* Java 15부터 `sealed` 인터페이스 사용
