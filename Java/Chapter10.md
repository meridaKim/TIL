# Chapter 10
## 라이브러리와 모듈
>참고 문헌 : 이것이 자바다

### 10.1 라이브러리
* 라이브러리 : 프로그램 개발 시 활용할 수 있는 클래스와 인터페이스를 `모아놓은 것`
* JAR 압축파일(.jar) 형태로 존재
* JAR : 클래스와 인터페이스의 바이트코드 파일들이 압축되어 있다.
* 프로그램 개발 시 라이브러리를 이용하려면 라이브러리 JAR 파일을 ClassPath에 추가해야 한다.
* ClassPath : 클래스 찾기 위한 경로

#### Classpath에 라이브러리 추가하는 방법
1. 콘솔(터미널)에서 프로그램을 실행할 경우 ->java 명령어를 실행할 때 -classpath로 제공
2. 이클립스 프로젝트에서 실행할 경우 -> build path에  추가

### 10.2 모듈
* 모듈 : Java 9부터 지원하는 패키지 관리 기능까지 포함된 라이브러리다.
* 모듈은 일부 패키지를 은닉하여 접근할 수 없게끔 할 수 있다.
* 모듈은 자신이 실행할 때 필요로 하는 의존 모듈을 `모듈 기술자`에 기술할 수 있기 때문에 **모듈간의 의존 관계를 쉽게 파악**할 수 있다.
* 대규모 응용프로그램은 기능별로 모듈화해서 개발할 수 있다. -> 모듈별 개발하고 조립하는 방식은 **재사용성 및 유지보수에 유리**

### 10.3 응용프로그램 모듈화

* 응용프로그램은 기능별로 모듈을 만들어 조합해서 개발할 수 있다.
* 모듈이 포함한 패키지를 외부에서 사용할 수 있도록 모듈 기술자에 exports pack 3, exports pack 4와 같이 작성
* 모듈의 패키지의 클래스를 사용할 때는 `import`를 사용한다.
### 10.4 모듈 배포용 JAR 파일
* 모듈 개발 후, 다른 모듈에서 쉽게 사용할 수 있도록 바이트코드 파일로 구성된 배포용 JAR 파일을 생성할 수 있다.
* dist 폴더를 추가하고 완성된 모듈을 JAR 파일로 생성
* 사용할 새로운 모듈에 export 받아 dist에 추가
* 구현 클래스에서 추상 메소드를 재정의할때 인터페이스의 추상메소드는 기본적으로 public 접근 제한을 가지기 때문에 더 낮은 접근 제한으로 재정의할 수 없다.


### 10.5 패키지 은닉
* 모듈은 모듈 기술자에서 `exports` 키워드를 사용하여 내부 패키지 중 외부에서 사용할 패키지를 지정
* exports되지 않은 패키지는 **자동 은닉**
* 은닉하는 이유
* * 모듈 사용 방법 통일 : 모듈 외부에서 은닉 패키지는 사용하지 못하도록 막고, exports 된 패키지로 사용방법을 통일한다.
* * 쉬운 수정 : 모듈 성능 향상을 위해 exports된 패키지를 수정해도 은닉된 패키지의 모듈 사용방법이 달라지지 않기 때문에 외부 영향을 주지 않는다.

### 10.6 전이 의존
* 프로젝트가 A모듈에 의존하고 A가 B에 의존한다고 가정
* 프로젝트의 모듈 기술자
```
    module my_application{
    requires my_module_a;
    }
```
* 모듈 A의 모듈 기술자
```
    module my_module_a{
    exports pack1;
    requires my_module_b;
    }
```

* 프로젝트의 모듈 기술자에는 requires my_module_b가 빠졌기 때문에 모듈 B 사용 불가
* 모듈 A만 사용하고 싶어도 C타입 객체를 만들어 리턴 시켜 모듈 B를 추가해야 한다.
* 모듈 A의 모듈 기술자에 `transitive` 키워드를 사용하여 모듈 B를 의존 설정하면 다른 타입 객체를 생성하지 않아도 된다. -> **의존 전의**

* 모듈 A의 모듈 기술자
```
    module my_module_a{
    exports pack1;
    requires transitive my_module_b;
    }
```

### 10.7 집합 모듈
* 집합 모듈 : 어려 모듈을 모아놓은 모듈
* 자주 사용되는 모듈들을 일일이 `requires`하는 번거로움 피할 수 있다.
* 자체적인 패키지를 가지지 않고, 모듈 기술자에 전이 의존 설정만 한다.
* 집합 모듈 mymodule

```
 module my_module{
   requires transitive my_module_a;
    requires transitive my_module_b;
    }
```
* 집합 모듈을 사용해도 모듈 A와 모듈 B는 프로젝트 ModulePath에 있어야 한다.(두 모듈을 프로젝트가 사용하기 때문)


### 10.8 리플렉션 허용
* 은닉된 패키지는 기본저긍로 다른 모듈에 의해 리플레션을 허용하지 않는다.
* 리플렉션 : 실행 도중에 타입을 검사하고 구성 멤버를 조사
* 모듈은 모듈 기술자를 통해 모듈 전체 또는 지정된 패키지에 대해 리플렉션을 허용할 수 있다.
* 모듈 전체 허용
```
    open module 모듈명{}
```
* 지정된 패키지 허용
```
   module 모듈명{
    opens 패키지 1;
     opens 패키지 2;
   }
```
* 모듈은 특정 외부 모듈에서만 리플레션을 허용할 수 있다.
* 지정된 패키지에 대해 특정 외부 모듈에서만 허용
```
   module 모듈명{
    opens 패키지 1 to 외부모듈명, 외부모듈명...;
     opens 패키지 2 to 외부모듈명;
   }
```
* `export된 패키지`는 언제든 리플렉션이 가능하므로 **opens 지정 필요 없다.**
* `opens`는 `은닉된 패키지` 중에서 특정 패키지에 대한 리플렉션 허용

### 10.9 자바 표준 모듈
* JDK가 제공하는 표준 라이브러리
* java.base 모듈은 모든 모듈이 의존하는 기본 모듈
* java.base은 requires하지 않아도 사용 가능
* java.base 모듈에는 lang, util, io 등의 핵심 패키지
* java.lang을 제외하고 import해서 사용 불가
* java.se는 JDK가 제공하는 모든 모듈을 제공하는 `집합 모듈` -> java 8 이전 버전처럼 제한 없이 사용하고 싶을 때 requires하면 된다.
