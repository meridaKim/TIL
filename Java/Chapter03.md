# Chapter 03
## 연산자
>참고 문헌 : 이것이 자바다

### 3.1 부호/증감 연산자

* 부호 연산자(+/-)는 변수의 부호를 유지하거나 변경한다.
* 부호 변경도 연산의 일부이기 때문에 정수 타입의 연산 결과로 int 타입 변수에 대입해야 한다.

```
byte b =100;
int result = -b; -> byte result은 컴파일 오류
```
* 증감 연산자는 변수 단독으로 사용될 경우, 변수의 앞뒤 어디에든 붙어도 결과가 같다.
* 여러 개의 연산자가 포함되어 있는 연산식에서는 증감 연산자의 위치에 따라 결과가 달라진다.
```
int x = 1;
int y = 2;
int result1 = ++x + 10; //x 증가 후 덧셈 연산
int result2 = y++ + 10; //덧셈 연산 후 y 증가
```
### 3.3 오버플로우와 언더플로우

#### 오버플로우
- 타입이 허용하는 최대값을 벗어나느 것을 말한다.

#### 언더플로우
- 타입이 허용하는 최소값을 벗어나는 것을 말한다.

`오버 플로우와 언더 플로우가 발생되면, 해당 정수 타입의 최소값 또는 최대값으로 되돌아 간다.`

`int 타입에서 오버플로우 또는 언더플로우가 발생될 가능성이 있다면 "long 타입 연산" 을 하자`

### 3.5 나눗셈 연산 후 NaN과 Infinity 처리

* 정수를 0으로 나누었을 때 예외 발생
* 실수를 0으로 나누거나, 0 대신 0.0, 0.0f이면 예외 발생하지 않고 __Infinity 또는 NaN(Not a Number)__ 발생!
* 확인 방법 : double.isIfinite(변수)/double.isNaN(변수)


### 3.6 비교 연산자
| 구분    | 메모리 크기   | 산출         |
|-------|-------|------------|
| 동등 비교  | == / !=  | true/false |
| 크기 비교| >/>=/</<=  | true/false |

* 피연산자의 타입이 다를 경우, 비교 연산 이전에 타입 일치시킨다.
* 예외 : 0.1f == 0.1 -> false[0.1f double 타입 변환되지 않는다.] (Because. 부동 소수점 방식을 사용하는 실수 타입은 0.1을 정확히 표현 할 수 없으며 double 타입의 정밀도 차이가 있기 때문)

* `0.1f == (float) 0.1 -> true`


* 문자열 비교 시 __equals()/ !equals()__ 사용한다.

### 3.7 논리 연산

* AND(논리곱) : "&&" -> 모두 true일 때만 true
* OR(논리합) : "||" -> 둘 중에 하나만 true여도 true
* XOR(배타적 논리합) : "^" -> 하나는 true 나머지는 false여야 true
* NOT(논리 부정) : "!" -> 논리가 바뀜

### 3.8 비트 논리 연산
* AND(논리곱) : "&" -> 모두 1일 때만 1
* OR(논리합) : "|" -> 둘 중에 하나만 1여도 1
* XOR(배타적 논리합) : "^" -> 하나는 1 나머지는 0여야 1
* NOT(논리 부정) : "!" -> 보수

#### 비트 연산이 필요한 이유
>예시) 소형 임베디드 장치의 C ㅍ로그램에서 외부 서버의 자바 프로그램으로 데이터 전달한다고 하면 C언어에는 unit8_t 타입이 있는데, 이 타입은 1byte 크기를 가지면서 0~255 값의 범위를 가진다.
C 프로그램 136 -> 자바 -120으로 읽음(자바는 최상위 비트가 1이면 음수로 인식)
->비트 논리곱 연산을 하면 136으로 복원 가능하다!

### 3.9 비트 이동 연산자
* a"<<"b : b만큼 왼쪽 이동, 오른쪽 빈자리는 0으로 채운다.
* a">>"b : b만큼 오른쪽 이동, 왼쪽 빈자리는최상위 부호 비트와 같은 값으로 채운다.
* a">>>"b : b만큼 오른쪽 이동, 왼쪽 빈자리는 0으로 채운다.

### 3.10 대입 연산자
* 우측 피연산자의 값을 좌측 피연산자인 변수에 대입.
* 단순 대입 연산자 : =
* 복합 대입 연산자 : 예시) += -> 변수 = 변수 + 피연산자


### 3.11 삼항(조건) 연산자
* 형태 : 조건식 ? 피연산자2(조건이 true일 때) : 피연산자3(조건이 false일 때)


### 3.12 연산의 방향과 우선순위

* 대입 연산자 오른쪽에서 왼쪽으로 연산 수행(증감, 부호, 비트, 논리도 같은 방향)
```
 a = b = c = 5 -> c, b, a 연산
```
