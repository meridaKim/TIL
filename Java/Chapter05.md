# Chapter 05
## 참조 타입
>참고 문헌 : 이것이 자바다

### 5.1 데이터 타입 분류

* 데이터 타입은 __기본 타입__ 과 __참조 타입__ 으로 분류된다.

#### 참조 타입 : 객체의 번지를 참조하는 타입으로, 배열, 열거, 클래스, 인터페이스 타입이 있다.

* 기본 타입 변수와 참조 타입 변수의 차이점

| 타입    | 저장하는 값         |
|-------|----------------|
| 기본 타입 | 값 자체           |
| 참조 타입 | 객체가 생성된 메모리 번지 |

#### 객체
객체란 데이터와 메소드로 구성된 덩어리

` 객체 = 데이터(필드) + 메소드`

변수들은 모두 스택이라는 메모리 영역에 생성되는데 기본 변수 타입인 int age와 int price는 직접 값을 저장하지만,
참조 변수 타입인 String name, String hobby는 힙 메모리 영역의  String 객체 번지를 저장하고 이 번지를 통해 String을 참조한다.



### 5.2 메모리 사용 영역
java 명령어로 JVM이 구동되면 운영체제에서 할당받은 메모리 영역(메소드 영역, 힙 영역, 스레드(스택 영역)를 포함)을 구분한다.

#### 메소드 영역
* 바이트코드 파일을 읽은 내용이 저장되는 영역으로 클래스별로 상수, 정적 필드, 메소드 코드, 생성자 코드 등이 저장

#### 힙 영역
* 객체가 생성되는 영역
* 객체의 번지는 메소드 영역과 스택 영역의 상수와 변수에서 참조

#### 스택 영역
* 메소드를 호출할 때마다 생성되는 프레임이 저장되는 영역
* 메소드 호출이 끝다면 프레임은 자동 제거
* 프레임 내부에는 로컬 변수 스택이 있으며 기본 타입 변수와 참조 타입 변수가 생성되고 제거된다.


### 5.3 참조 타입 변수의 ==, != 연산

참조 타입 변수의 ++, != 연산자는 __번지를 비교__ 

* 번지가 다르면 다른 객체를 참조


`결과는 true/false`

```
int[] arr1= new int[] {1,2,3} ;
int[] arr2= new int[] {1,2,3} ;
int[] arr3;
arr2= arr3;
System.out.println(arr1 == arr2); //결과 : false
System.out.println(arr2 == arr3); //결과 : true
```
* arr1 과 arr2는 저장항목이 같지만 서로 다른 배열 객체로 생성되므로 변수에 대입되는 번지가 다름
* arr3는 arr2 변수의 번지가 대입되었기 때문에 두 변수는 동일한 번지를 가지며 같은 배열을 참조한다.


### 5.4 null과 NullPointerException

#### null

`null은 아직 번지를 저장하고 있지 않다는 의미`

* null도 초기값으로 사용될 수 있기 때문에 null 초기화된 변수도 스택 영역에 생성된다!

`null 값 확인은 ==, != 연산 수행으로 알 수 있다.`

#### NullPointerException'

```
int [] intArray = null;
intArray[0] = 10;       //NullPointerException!
```

* 배열 변수에 null 대입한 상태에서 10 대입하는 코드를 실행하면 NullPointerException 발생

-> intArray가 참조하는 배열 객체가 없기 때문에 10 저장 X

```
String str = null;
System.out.println("총 문자 수: " + str.length());      //NullPointerException!
```

*  변수에 null 대입한 상태에서 length() 메소드를 호출하면 NullPointerException 발생

-> str 변수가 참조하는 String 객체가 없기 때문에 문자열의 길이를 구할 수 X

__NullpointerException 해결 방법 : 참조 변수가 객체를 정확히 참조하도록 번지를 대입해야 한다__

일부러 null을 대입하면 번지를 잃게 되어 객체 사용할 수 없다.


`힙 메모리에 존재하지만 위치 정보를 모르기 때문에 사용할 수 없는 객체는 Garage Collector를 실행 시켜 자동으로 제거`

```
    String kind1 = "자동차";
    String kind2 = kinds;
    kind1 = null;
    System.out.println(kind2);  //결과 = "자동차"
```
kind1 변수에 null을 대입한다고 해서 자동차에 해당하는 String 객체가 쓰레기가 되지 않는다.
-> kind2가 여전히 참조하고 있기 때문이다.

### 5.5 문자열 타입(String)

#### 문자열 비교
 자바는 문자열 리터럴이 동일하다면 String 객체를 공유하도록 설계되어 있다.

```
    String name1 = "홍길동";
    String name2 = "홍길동";   //name1과 name2는 동일한 String 객체의 번지가 저장된다.
```
 new 연산자로 직접 String 객체를 생성하고 대입할 수 있다. 

* `new : 객체 생성 연산자`

```
    String name1 = new String("홍길동");
    String name2 = new String("홍길동");   
    //name1과 name2는 서로 다른 String 객체의 번지를 가진다.
```

equal()로 동일한 String 객체이든 다른 String 객체든 상관없이 내부 문자열만 비교할 경우 사용
* `equal() : 내부 문자열만 비교`

```
boolean result = str1.equals(str2);
//str1 = 원본 문자열, str2 = 비교 문자열
```

* String 변수에 __빈 문자열("")__ 대입 가능

#### 문자 추출
`charAt() : 문자열에서 특정 위치의 문자 리턴`

* 문자열은 `0부터 문자열의 길이 - 1`까지의 인덱스 번호를 가진다.

#### 문자열 길이
`length() : 문자열에서 문자의 개수`
* 문자열 길이는 __공백을 포함__ 한 길이이다.
* 
#### 문자열 대체
`replace(): 특정 문자열을 다른 문자열로 대체`
* 기존 문자열은 그대로 두고, 대체한 새로운 문자열을 리턴한다.
* String 객체의 문자열은 변경이 불가한 특성을 갖기 때문에 replace()가 리턴하는 문자열은 원래 문자열의 수정본이 아니라 완전히 새로운 문자열이다.

#### 문자열 잘라내기
`substring() : 특정 위치의 문자열 잘라내기`

| 메소드                                     | 설명                       |
|-----------------------------------------|--------------------------|
| substring(int beginIndex)               | beginIndex에서 끝까지         |
| substring(int beginIndex, int endIndex) | beginIndex에서 endIndex앞까지 |

#### 문자열 찾기
`indexOf() : 특정 문자열 위치 찾기`
* 문자열이 포함되어 있지 않으면 indexOf() -1 리턴.

`contains : 주어진 문자열의 포함여부 확인(true/false)`

#### 문자열 분리
`split() : 구분자를 통해 문자열 분리하기`
* 분리된 문자열로 구성된 배열을 얻을 수 있다.


### 5.6  배열 타입

* 배열은 연속된 공간에 값을 나열시키고, 각 값에 인덱스를 부여해 놓은 자료구조이다.

* `인덱스 : 대괄호 []와 함께 각 항목의 값을 읽거나 저장하는데 사용`

#### 배열의 특징
```
 배열은 같은 타입의 값만 관리한다.
 배열의 길이는 늘리거나 줄일 수 없다.
```
#### 배열 변수 선언

```
타입[] 변수;
타입 변수[];
```
* 배열 변수는 참조 변수이다. 배열도 __객체__ 이므로 힙 영역에 생성되고 배열 변수는 힙 영역의 배열 주소를 저장한다.
* 참조할 배열이 없다면 배열 변수도 null로 초기화할 수 있다.

` String[] strArray = null; `

#### 값 목록으로 배열 생성

* ` 타입[] 변수 = {값1, 값2, 값3...}`

* 중괄호{ } 로 감싼 값의 목록을 배열 변수에 대입할 때, 배열 변수를 미리 선언한 후 값 목록을 변수에 대입할 수 없다!

```
    타입[] 변수;
    변수 = {값1, 값2,..} //컴파일 에러
```

* 배열 변수 선언 시점과 값 목록 대입 시점이 다르다면, new 타입[]을 붙인다.
```
    변수 = new 타입[] {값1, 값2,..} 
```
```
    String[] names = null;
    names = new String[] {"홍길동","김자바"} ;
```

* 메소드의 매개변수가 배열타입일 경우 메소드 호출 방법
```
    void printItem(int[] scores){ ...}
    
    printItem(new int[] {98, 56, 23});
```
#### new 연산자로 배열 생성
* 값의 목록이 없지만 미리 생성할 때

```
타입[] 변수 = new 타입[길이];

타입[] 변수 = null;
변수 = new 타입[길이];
```

* char[]의 초기값은 '\u0000'
* boolean[]의 초기값은 'false'

#### 배열 길이
* 배열의 길이란 배열에 저장할 수 있는 항목 수

* `배열변수.length()`

* 길이 읽기는 가능하지만 __변경__ 은 불가하다.

### 5.7 다차원 배열

* 배열 항목에 또 다른 배열이 대입된 형태(2차원, 3차원)
* `변수 [1차원인덱스][2차원 인덱스]`


#### 값 목록으로 다차원 배열 생성
```
int[][] scores = {
    {80,90,70},
    {78,56},
};
```
* 다차원 배열의 길이 또한 __length__ 를 통해 알 수 있다.
```
scores.length; -> 2
score[0].length; -> 3
score[1].length; -> 2
```

#### new 연산자로 다차원 배열 생성
```
int[][] scores = new int[2][3]; 
-> 기본 타입 int이므로 모두 0으로 초기화, String은 null로 초기화, 실수타입은 0.0으로 초기화
```

### 5.8 객체를 참조하는 배열
String[] 배열의 항목은 String 변수와 동일하게 참조 타입 변수로 취급한다.
배열에 저장된 문자열은 해당 문자열을 저장하는 String 객체를 가진다.

그렇기 때문에 `==, !=`로 배열 항목이 참조하는 객체가 같은 객체인지 확인하고 `equals()메소드`로 문자열을 비교한다.

### 5.9  배열 복사

* 배열은 한 번 생성하면 길이를 변경할 수 없기 때문에, 길이 변경 시 기존 배열 항목을 복사하고 새로운 배열에 저장해야 한다.

#### for문을 이용한 배열 복사(항목 하나씩 읽고 새로운 배열에 저장)

```
int[] oldArr = {1.2.3};
int[] newArr = new int[5];

for(int i = 0; i<oldArr.length; i++){
    newArr[i] = oldArr[i];
}
// 항목 하나씩 읽고 새로운 배열에 저장
```

#### System.arraycopy()를 이용한 배열 복사

```
System.arraycopy(Object src, int srcPos, Odject dest, int destpos, int length);
// src : 원본 배열, srcPos : 원본 배열 복사 시작 인덱스, dest : 새로운 배열, destpos : 새 배열 붙여넣기 시작 인덱스, length : 복사 항목 수
```

* 항목의 값이 String 객체의 번지이므로 번지 복사가 되어 __참조하는 String 객체는 변함이 없다.__

### 5.10 배열 항목 반복을 위한 향상된 for 문
* 카운터 변수와 증감식을 사용하지 않고, 항목의 개수만큼 반복한 후 자동으로 for문을 빠져나간다.

```
for ( 2. 타입 변수 : 1.배열 ){
        
        //3. 실행문
}
```
1. 배열에서 가져올 항목이 있다면 
2. 변수에 항목을 저장하고
3. 실행문을 실행한다.

__반복 시 2, 3, 1 순으로 진행한다.__

### 5.11 main()메소드의 String[] 매개변수 용도

* main() 메소드 작성 시, 문자열 배열 형태인 String[] args 매개변수를 사용한 이유
 
입력 받은 값은 공백으로 구분된 문자열로 취급 되고 String[] 배열의 항목 값으로 구성된다.
main() 메소드 호출 시 매개값으로 전달된다.

`args[0], args[1]...에 저장`

이때 int 타입으로 변환하기 위해 강제 타입 변환한다.

`int x = Integer.parseInt(args[0]);`

실행될 때 몇 개의 값이 입력되었는지 확인하기 위해 main()의 length로 확인할 수 있다.

### 5.12 열거(Enum) 타입

`Enum : 한정된 값을 갖는 타입`

* 열거 타입 이름으로 소스 파일을 생성하고 한정된 값을 코드로 정의한다. 이때, 열거 타입 이름은 첫 문자를 __대문자__ 로 하고 캐멀스타일로 지어준다.
* `열거 상수 : 열거 타입으로 사용할 수 있는 한정된 값으로 대문자로 작성하고, 여려 단어로 구성할 시 언더바(_)로 연결한다.`
* 열거 타입도 하나의 데이터 타입으로 변수를 선언하고 사용해야 한다.
*  변수에 열거 상수 대입 예시
```
Week today = Week.SUNDAY;
week birthday = null; // 열거 타입은 참조 타입이므로 null 대입 가능
today == Week.SUNDAY; // 변수값이 SUNDAY인지 비교
```

