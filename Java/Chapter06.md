# Chapter 06
## 클래스
>참고 문헌 : 이것이 자바다

### 6.1 객체 지향 프로그래밍

객체를 먼저 만들고 객체들을 조립해서 완성된 프로그램을 만드는 기법을 객체 지향 프로그래밍이라고 한다.

#### 객체란
`객체 : 물리적으로 존재하거나 개념적인 것 중에서 다른 것과 식별이 가능한 것`
* 객체는 __속성과 동작__ 으로 구성한다. 
* 속성과 동작을 __필드와 메소드__ 라 부른다.
* 현실 세계의 객체를 소프트웨어 객체로 설계하는 것을 __객체 모델링__ 이라ㅣ고 한다.

#### 객체의 상호작용

* 객체 지향 프로그램에서 객체들은 다른 객체와 서로 상호작용한다,
* 객체들 사이의 상호작용 수단은 __메소드__ 이다.
* 객체가 다른 객체의 기능을 이용할 때 메소드를 __호출__ 한다.
* 메소드 호출 형태
```
    메소드(매개값1, 매개값2..)
    // 메소드 이름과 함께 전달하고자 하는 데이터(매개값)를 괄호 안에 기술
```
* `매개값 : 전달하고자 하는 데이터, 메소드가 실행할 때 필요한 값`
* `리턴 값 : 메소드 실행의 결과, 호출한 곳으로 돌려주는 값`
* 메소드의 리턴값은 호출한 곳에서 변수로 대입받아 사용한다.
```
int result = add(10,20); // 리턴값을 int 변수에 저장
```
#### 객체 간의 관계

1. 집합 관계
: 자동차와 부품

2. 사용 관계
: 사람이 자동차에게 달린다 메소드를 호출

3. 상속 관계
: 부모와 자식 관계

#### 객체 지향 프로그래밍의 특징

1. 캡슐화
: 데이터(필드), 동작(메소드)을 하나로 묶고 실제 구현 내용을 __외부에 감춘다.__ 
-> 외부의 잘못된 사용으로 객체가 손상되지 않도록 하기 위해서

2. 상속
: 부모 역할의 상위 객체인 부모 객체는 자기가 가지고 있는 필드와 메소드를 하위 객체인 자식 객체가 사용할 수 있도록 한다.

* 코드의 재사용성 높여준다.
* 유지 보수 시간을 최소화

3. 다향성
: __사용 방법은 동일하지만 실행 결과가 다양하게 나오는 성질__ 로, 자동차의 부품을 교체하면 성능이 다른게 나오듯이 프로그램을 구성하는 객체를 바꾸면 프로그램의 실행 성능이 다르게 나올 수 있다.


### 6.2 객체와 클래스
`클래스 : 객체를 생성하기 위한 설계도`

`인스턴스 : 클래스로부터 생성된 객체`

-> 클래스로부터 객체를 만드는 과정: __인스턴스화__
(하나의 설계도로 여러 대의 자동차를 만드는 것)

### 6.3 클래스 선언

`객체 생성을 위한 설계도 작성하는 작업`

* 어떻게 객체를 생성(생성자)하고 객체가 가져야 할 데이터(필드)가 무엇이고, 객체의 동작(메소드)은 무엇인지를 정의하는 내용 포함

* 클래스 명은 첫 문자를 대문자로 하고, 특수 문자 중 $,_를 포함할 수 있다.
* 하나의 소스 파일에는 복수 개의 클래스 선언을 포함할 수 있다.
```java
    public class SportCar {
    
    }
    class Tire{
    
    }
```
* 소스 파일명과 동일한 클래스만 공개 클래스(public)로 선언할 수 있다.


### 6.4 객체 생성과 클래스 변수

* 클래스로부터 객체를 생성하기 위해서 객체 생성자인 new가 필요하다.

`new 클래스()`
* new 연산자는 객체를 생성시킨 후 객체의 주소를 리턴하기 때문에 클래스 변수에 대입할 수 있다.

`클래스 변수 = new 클래스();`

```java

public class Student{
    
}
```
```java

public class StudentExample{
    public static void main(String[] args){
        Student s1 = new Student();
        //s1 변수가 Student 객체를 참조
        Student s2 = new Student();
        //s2 변수가 Student 객체를 참조
    }
}
```

#### 클래스의 두가지 용도
* 라이브러리 : 실행할 수 없으며 다른 클래스에서 이용하는 클래스 -> Student.class
* 실행 클래스 : main() 메소드를 가지고 있는 실행 가능한 클래스 -> StudentExample.class

### 6.5 클래스의 구성 멤버
* 필드 : 객체의 데이터가 저장되는 곳
* 생성자 : new 연산자로 객체 생성할 때 초기화 역할 담당, 리턴 타입이 없고 이름은 클래스 이름과 동일
* 메소드 : 객체의 동작으로 호출 시 실행하는 동작이 담긴 블록, 함수라고도 하며 객체 내부의 함수는 메소드라고 부른다.
객체와 객체간의 상호작용을 위해 호출된다.
* 
```java

public class ClassName{
       int fieldName; //필드 선언
        ClassName(){   } // 생성자 선언
        int methodName(){    }  //메소드 선언
    
    }

```



### 6.6 필드 선언과 사용

`필드 : 객체의 데이터를 저장하는 역할`

#### 필드 선언
* 클래스 블록에서 선언되어야 필드 선언이 된다.
#### 필드와 로컬 변수의 차이점

* 로컬 변수는 생성자와 메소드 블록에서 선언되며 생성자와 메소드 호출 시에만 생성되고 사용된다.
* 필드는 클래스 블록에서 선언되고, 객체 내부에서 존재하고 객체 내/외부에서 사용 가능하다.

| 구분    | 필드             | 로컬 변수                |
|-------|----------------|----------------------|
| 선언 위치 | 클래스 선언 블록      | 생성자, 메소드 선언 블록       |
| 존재 위치 | 객체 내부에 존재      | 생성자, 메소드 호출 시에만 존재   |
| 사용 위치 | 객체 내/외부 어디든 사용 | 생성자, 메소드 블록 내부에서만 사용 |
* 필드 선언 예시
```java
public class Car{
    String model = "그랜져";
    Tire tire = new Tire();
}
```

```java
public class Car{
    String model; //null
    Tire tire; // null
}
```

#### 필드 사용
* 필드를 읽고 변경하는 것으로, 필드는 클래스로부터 객체가 생성된 후에 사용할 수 있다.(필드는 객체의 데이터이므로)
* 외부 객체에서의 사용 : myCar.speed -> 도트 연산자 사용
* `도트 연산자 : 객체 접근 연산자로, 객체가 가지고 있는 필드나 메소드에 접근하고자 할 때 참조 변수 뒤에 붙인다.`

### 6.7 생성자 선언과 호출
#### 메소드 선언
객체의 동작을 실행 블록으로 정의
```
리턴 타입 메소드 명 (매개변수, ...)// -> 선언부
{
        실행할 코드 작성 // -> 실행블록
}
```
* `리턴 타입 : 메소드가 실행한 후 호출한 곳으로 전달하는 결과값의 타입, 리턴 값이 없는 메소드는 void로 작성`
* 리턴 타입이 있는 있는 메소드는 return 문으로 리턴값을 반드시 지정
* `메소드명 : 첫 문자를 소문자로 시작하고, 캐멀 스타일로 작성`
* `매개변수 : 메소드를 호출할 때 전달한 매개값을 받는 곳`
* 매개 변수는 전달 받을 매개값의 갯수 만큼 필요하다.

#### 메소드 호출
실행 블록을 실제로 실행, 메소드는 객체의 동작이므로 객체가 존재하지 않으면 메소드를 호출할 수 없다.
* 외부 객체에서 참조 변수와 도트 연산자를 이용하여 호출
* 메소드가 리턴값이 있을 경우, 대입 연산자를 사용하여 리턴값을 변수에 저장해야 한다.
* `타입 변수명 = 메소드()`

#### 가변 길이 매개 변수
* 가변 길이 매개 변수 : 매개변수의 개수에 맞게 매개값 제공
* 가변 길이 매개 변수는 메소드 호출 시 매개값을 쉼표로 구분해서 개수와 상관없이 제공할 수 있다.

가변길이 매개변수 선언 방법
```
    int sum(int ... values){
    }
```
```
    int result = sum(1,2,3);
    int result = sum(1,2,3,4,5);
```
* 매개값들은 자동으로 배열 항목으로 변환되어 메소드에 사용되기 때문에 메소드 호출 시 직접 배열을 매개값으로 제공해도 된다.
```
    int[] values = {1,2,3,4};
    int result = sum(values);
    int result = sum(new int[] {1,2,3});
```
#### return문
* `return : 메소드의 실행을 강제 종료하고 호출한 곳으로 돌아간다.`
* return문 이후에 실행문 작성하면 'Unreachable code'라는 컴파일 에러 발생
* return문 이후의 실행문은 실행되지 않는다!

#### 메소드 오버로딩
* `메소드 오버로딩 : 메소드 이름은 같지만 매개변수의 타입, 개수, 순서가 다른 메소드를 여러 개 선언`
* 다양한 매개값을 처리하기 위해서 사용

```
    void println(){ }]
    void println(double x){}
    void println(int x){}
    void println(String x){}
```

### 6.9 인스턴스 멤버
* `인스턴스 멤버: 객체에 소속된 멤버, 객체가 있어야만 사용`
* car 클래스에 필드 gas 와 setSpeed() 메소드를 선언하면 인스턴스 멤버가 된다.
```
     public class Car{
        
        int gas;
        
        void setSpeed(int speed){ ... }
     
     }
```
* 외부 클래스에서 인스턴스 멤버를 사용하기 위해서는 Car 객체를 먼저 생성하고 참조 변수로 접근해야 한다.

```
     Car yourCar = new Car();
     yourCar.gas = 20;
     yourCar.setSpeed(80);
```
-> gas 필드는 Car 객체마다 따로 존재하고 setSpeed()메소드는 각 객체마다 존재하지 않고 메소드 영역에 저장되고 공유된다.
* 인스턴트 멤버는 객체에 __소속된 멤버__ , gas 필드는 객체에 소속된 멤버이지만 setSpeed() 메소드는 객체에 포함되지 않는다.
* 메소드(코드의 덩어리)는 메모리 효율(중복저장 방지)을 위해 메소드 영역에 두고 공유에서 사용하고 객체 없이는 사용하지 못하도록 제한을 걸어둔다.

#### this
* `this : 객체 자기 자신, 생성자와 메소드의 매개변수명이 인스턴스 멤버인 필드명과 동일한 경우, 인스턴스 필드임을 강조하기 위해 사용`
```java
    public class Car{
    //필드 선언
    String model;
    int speed;
    
    //생성자 선언
    Car(String model){
        this.model = model; //매개변수를 필드에 대입(this 생략 불가)
    }
    //메소드 선언
    void setSpeed(int speed){
        this.speed = speed; //매개변수를 필드에 대입(this 생략 불가)
    }
    void run(){
        this.setSpeed(100); //this 생략 가능
    }
}
```
```java
    public class CarEx{
    public static void main(String[] args){
        Car myCar = new Car("포르쉐");
        Car yourCar = new Car("벤츠");

        myCar.run();
        yourCar.run();
    }
}
```

### 6.10 정적 멤버

* `정적(static) 멤버 : 메소드 영역의 클래스에 고정적으로 위치하는 멤버, 객체 생성 필요 없이 클래스 통해 바로 사용 가능`

#### 정적 멤버 선언
* 필드와 메소드 모두 정적 멤버가 될 수 있다.
* 객체마다 가지고 있을 필요성이 없는 공용적인 필드는 정적 필드로 선언하는 것이 좋다. 예를 들어, 모든 계산기에 들어가는 파이는 계산기 객체마다 가질 필요가 없다.
* 인스턴스 필드를 이용하지 않는 메소드는 정적 메소드로 선언하는 것이 좋다. 계산기의 plus 메소드는 외부에서 주어진 매개값들을 가지고 처리함로 정적 메소드 선언이 좋다.
```
    public class 클래스{
    
    static 타입 필드 ; //정적 필드 선언
    static 리턴타입 메소드(매개변수, ....){...} // 정적 메소드 선언
    
    }

```

#### 정적 멤버 사용
* 클래스 이름과 함께 도트 연산자로 접근하면 된다.
* 객체 참조 변수로도 접근이 가능하다.
```
    public class calculator{
    
    static double pi = 3.14; //정적 필드 선언
    static int plus(int x, int y){...} // 정적 메소드 선언
    static int minus(int x, int y){...}
    }
```
```
    double result1 = 10*10*Calculator.pi;
    int result2 = Calculator.plus(10,5);
    int result3 = Calculator.minus(10,5); // 도트 연산자로 정적 메소드 사용
```
```
    Calculator myCal = new Calculator();
    double result1 = 10*10*myCal.pi;
    int result2 = myCal.plus(10,5);
    int result3 = myCal.minus(10,5); // 객체 참조 변수로도 접근 가능
```

#### 정적 블록
* `정적 블록 : 복잡한 초기화 작업이 필요할 때 사용`
* 클래스가 메모리로 로딩될 때 자동 실행, 정적 블록이 클래스 내부에 여러 개 선언되어 있을 경우, __선언 순서대로 실행__
* 정적 블록 형태
```
    static {
        ...
    }
```

#### 인스턴스 멤버 사용 불가
* 정적 메소드와 블록은 객체가 없어도 실행된다는 특징 때문에 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다. this도 사용 불가.
* 정적 메소드와 블록에서 인스턴스 멤버를 사용하고 싶다면 __객체 먼저 생성 후 참조 변수로 접근__ 해야 한다.
* 정적 메소드인 main() 메소드에서도 동일한 규칙 적용
```
    public class ClassName{
    
    //인스턴스 필드와 메소드 선언
    int field1;
    void method1(){}
    
    //정적 필드와 메소드 선언
    static int field2;
    static void method3(){}; 
    
    //정적 블록 선언
    static{
        field1 = 10; -> 컴파일 에러
        method1(); -> 컴파일 에러
        field2 = 10;
        method2();
    }
    static void method3(){
        this.field1 = 10; -> 컴파일 에러
        this.method1(); -> 컴파일 에러
        field2 = 10;
        method2();
    }
    static void method4(){
    // 객체 생성
        ClassName obj = new ClassName();
    //인스턴스 멤버 사용
        obj.field1 = 10;
        obj.method1();
    }
    }
```
### 6.11 final 필드와 상수
* `final : 초기값이 저장되면 프로그램 실행 도중에 수정 불가를 의미`
* 필드 선언시에 초기값 대입, 생성자에서 초기값 대입
* `상수 : 불변의 값을 저장하는 필드로 대문자로 작성`
* 상수는 객체마다 저장할 필요가 없고, 여러 개의 값을 가져도 안되기 때문에 __static이면서 final__ 인 특성을 가져야 한다.
* 상수 선언 방법

 `static final 타입 상수 = 초기값;`
* 복잡한 초기화 필요시, 정적 블록에서의 초기화 가능
```
    static final 타입 상수;
    static{
        상수 = 초기값;
    }
```
* 정적 필드이므로 클래스로 접근해서 읽을 수 있다. `클래스명.상수`


### 6.12 패키지
* 패키지는 클래스의 일부분, 클래스를 식별하는 용도로 사용
* 개발 회사의 도메인 이름의 역순으로 만든다.
* 상위와 하위 패키지를 도트(.)로 구분한다.
* 패키지 이름은 모두 소문자로 작성한다. 회사 도메인 이름의 역순, 마지막에 프로젝트 이름을 붙여준다.
* 다른 패키기의 클래스를 사용하기 위해서 `import`문을 통해 어떤 패키지의 클래스를 사용하는지 명시해야 한다.

### 6.13 접근 제한자
* 중요한 필드와 메소드가 외부로 노출되지 않도록 하여 `객체의 무결성`을 유지하기 위함

| 접근 제한자    | 제한 대상             | 제한 범위                  |
|-----------|-------------------|------------------------|
| public    | 클래스, 필드, 생성자, 메소드 | 없음                     |
| protected | 필드, 생성자, 메소드 | 같은 패키지이거나 자식 객체만 사용 가능 |
| (default) | 클래스, 필드, 생성자, 메소드 | 같은 패키지                 |
| private   | 필드, 생성자, 메소드  | 객체 내부                  |

### 6.14 Getter, Setter
* 객체의 무결성을 지키기 위해 객체지향 프로그래밍에서는 직접적인 외부에서의 필드 접근을 막고 메소드를 통해 필드에 접근하는 것을 선호
* `Setter: 데이터를 검증하여 유효한 값만 필드에 저장`
* private 접근 제한을 가지는 필드는 외부에서 접근하지 못하므로 Setter인 set필드명() 메소드를 이용
* `Getter : 필드값이 객체외부에서 사용하기 부적절한 경우, 메소드로 적절한 값으로 변환하여 리턴`
* private 접근 제한을 가지는 필드는 외부에서 접근하지 못하므로 Getter인 get필드명() 메소드를 이용
* Getter와 Setter 예시
```
    private int fieldName;
    
    public int getFieldName(){
        return fieldName;
        }
        //접근 제한자 : public, 리턴 타입 : 필드타입 , 메소드 이름: get+ 필드이름, 리턴값 : 필드값
    
    public void setFieldName(int fieldName){
        this.fieldName = fieldName;
    }
    //접근 제한자 : public, 리턴 타입 : void , 메소드 이름: set+ 필드이름, 매개변수 타입 : 필드타입
```

### 6.15 싱글톤 패턴
* `싱글톤 패턴 : 단 한 개의 객체만 생성해서 사용`
* 생성자를 private 접근 제한해서 외부에서 new 연산자로 생성자를 호출할 수 없도록 막는 것
* 외부에서 마음대로 객체를 생성하지 못하지만 싱글톤 패턴이 제공하는 정적 메소드를 통해 간접적으로 객체를 얻을 수 있다.
```
    public class 클래스{
    
        //private 접근 권한을 갖는 정적 필드 선언과 초기화
        private static 클래스 singleton = new 클래스();
        
        
        //private 접근 권한을 갖는 생성자 선언
        private 클래스(){}
        
        //public 접근 권한을 갖는 정적 메소드 선언
        public static 클래스 getInstance(){
            return singleton;
        }
    
    }

```
* 먼저 자신의 타입으로 정적 필드르 선언하고 미리 객체를 생성해서 초기화 시킨다.
* 정적 필드값을 리턴하는 getInstance() 정적 메소드를 public으로 선언
* 외부에서는 getInstance()로 객체를 생성할 수 있다. getInstance메소드가 리턴하는 객체는 정적 필드가 참조하는 싱글톤 객체이다.
* 변수 1과 변수 2가 참조하는 객체는 동일한 객체가 된다.(싱글톤 객체)

```
  클래스 변수1 = 클래스.getInstance();
  클래스 변수2 = 클래스.getInstance();
```
